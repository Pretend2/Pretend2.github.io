[{"title":"多线程","date":"2022-10-28T02:12:47.000Z","url":"/2022/10/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","categories":[["undefined",""]],"content":"多线程核心概念： 线程就是独立的执行路径； 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程； main()称之为主线程，为系统的入口，用于执行整个程序； 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制； 线程会带来额外的开销，如cpu调度时间，并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。 继承Thread类（重点） 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承的局限性 实现Runnable接口（重点） 实现接口Runnable具有多线程能力 启动线程：传入目标对象 + Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 实现callable接口实现步骤： 实现callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行任务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1); 提交执行：Future result1 &#x3D; ser.submit(t1); 获取结果：boolean r1 &#x3D; result1.get(); 关闭服务：ser.shutdownNow(); 好处： 可以定义返回值 可以抛出异常 静态代理静态代理模式总结： 真实对象和代理对象都要实现同一个接口 代理对象要代理真实对象 好处： 代理对象可以做很多真实对象做不了的事情 真实对象专注做自己的事情 Lambda表达式理解Functional Interface（函数式接口）是学习Java8 Lambda表达式的关键所在。 函数式接口的定义：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。 对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象。 为什么要使用Lambda表达式： 避免匿名内部类定义过多 可以让你的代码看起来很简洁 去掉了一堆没有意义的代码，只留下核心的逻辑。 Lambda表达式的简化： lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行那么就用代码块包裹。 前提是接口为函数式接口 多个参数也可以去掉参数类型，要去掉就都去掉 线程停止 建议线程正常停止 -&gt; 利用次数，不建议是循环。 建议使用标志位 -&gt; 设置一个标志位 不要使用stop或者destroy等过时或者JDK不建议使用的方法 示例： 转态线程休眠 **sleep(时间)**指定当前线程阻塞时间的毫秒数； sleep存在异常InterruptedException； sleep时间达到后线程进入就绪状态； sleep可以模拟网络延时，倒计时等。 每一个对象都有一个锁，sleep不会释放锁； 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功！看CPU心情 线程状态观测 Thread.State 线程状态。线程可以处于以下状态之一： NEW 尚未启动的线程处于此状态。 RUNNABLE 在Java虚拟机中执行的线程处于此状态。 BLOCKED 被阻塞等待监视器锁定的线程处于此状态。 WAITING 正在等待另一个线程执行特定动作的线程处于此状态。 TIMED WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 TERMINATED 已退出的线程处于此状态 一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。 Thread t &#x3D; new Thread() 线程对象一旦创建就进入到了新生状态。 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行。 当调用sleep，wait或同步锁定时线程进入阻塞状态，就是代码不往下执行，阻塞阻塞事件解除后，重新进入就绪状态，等待cpu调度执行。 进入运行状态，线程才真正执行线程体的代码块。 线程中断或者结束，一旦进入死亡状态，就不能再次启。 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围从1-10. Thread.MIN_PRIORITY &#x3D; 1； Thread.MAX_PRIORITY &#x3D; 10； Thread.NORM_PRIORITY &#x3D; 5； 使用以下方式改变或获取优先级 getPriority().setPriority(int xxx) 注意：先设置优先级再启动！ 守护(daemon)线程线程分为用户线程和守护线程。虚拟机必须确保用户线程执行完毕。虚拟机不用等待守护线程执行完毕。如，后台记录操作日志，监控内存，垃圾回收等待.. 线程同步（重点、难点）多个线程操作同一个资源并发：同一个对象被多个线程同时操作 现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题，比如，食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队.一个个来. 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步.线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线，程再使用。 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题. 同步方法 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法： synchronized 方法和synchronized块.同步方法：public synchronized void method(int args){} synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行 缺陷：若将一个大的方法申明为synchronized 将会影响效率 同步块 同步块：synchronized**(Obj){}** Obj称之为同步监视器 Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class[反射中讲解】 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码. 第二个线程访问，发现同步监视器被锁定，无法访问. 第一个线程访问完毕，解锁同步监视器. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问. 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题 错误代码： 正确代码： 死锁避免方法产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生 Lock（锁） 从JDK 5.0开始，Java提供了更强大的线程同步机制通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。 锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock（可重入锁）类实现了 Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 示例： synchronized 与Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock &gt;同步代码块（已经进入了方法体，分配了相应资源）&gt; 同步方法（在方法体之外） 线程协作（难点、重点）生产消费者模式 线程通信 应用场景：生产者和消费者问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费. 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止. 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止. Java提供了几个方法解决线程之间的通信问题 方法名 作用 wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁. wait(long timeout) 指定等待的毫秒数. notify() 唤醒一个处于等待状态的线程. notifyAll() 唤醒同一个对象上所有调用wait（）方法的线程，优先级别高的线程优先调度. 注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常llegalMonitorStateException 解决方式1并发协作模型“生产者&#x2F;消费者模式”–&gt;管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）； 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）； 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 示例 解决方式2并发协作模型“生产者&#x2F;消费者模式”–&gt;信号灯法 示例 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。 可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理（….） corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 使用线程池 JDK 5.0起提供了线程池相关API:ExecutorService 和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute（Runnable command）：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable Future submit（Callable-T&gt;task）：执行任务，有返回值，一般又来执行Callable void shutdown（）：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 示例 创建线程的三种方式"}]